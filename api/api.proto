syntax = "proto3";

import "config.proto";

/* Commands sent by the client */

message PowerOn {
  // Setpoint represented as a hundredth of a degree celsius
  // i.e. you'll get the real decimal representation by multiplying
  // this number by 100.
  uint32 setpoint = 1;
}
message PowerOff { }

message StartBrew { }
message StopBrew { }

message StartPump { }
message StopPump { }

message StartSteam {
  // Setpoint represented as a hundredth of a degree celsius
  // i.e. you'll get the real decimal representation by multiplying
  // this number by 100.
  uint32 setpoint = 1;
}
message StopSteam { }

message BackflushStart { }
message BackflushStop { }

message RinseStart { }
message RinseStop { }

message Command {
  // A unique client-generated request identifier.
  // This will be embedded into a command response coming from the server
  // so the client can route the response appropriately.
  bytes request_id = 1;

  oneof command_oneof {
    PowerOn power_on = 2;
    PowerOff power_off = 3;

    StartBrew start_brew = 4;
    StopBrew stop_brew = 5;

    StartPump start_pump = 6;
    StopPump stop_pump = 7;

    StartSteam start_steam = 8;
    StopSteam stop_steam = 9;

    // Set the configuration
    Config config = 10;

    BackflushStart backflush_start = 11;
    BackflushStop backflush_stop = 12;

    RinseStart rinse_start = 13;
    RinseStop rinse_stop = 14;
  }
};

/* Events sent by the server */

message Uint32Result {
  oneof result {
    uint32 value = 1;
    string error = 2;
  }
};
message Int32Result {
  oneof result {
    int32 value = 1;
    string error = 2;
  }
};

enum MachineMode {
  UNKNOWN = 0;
  PANIC = 1;
  OFF = 2;
  IDLE = 3;
  BREWING = 4;
  BACKFLUSHING = 5;
  PUMPING = 6;
  STEAMING = 7;
  RINSING = 8;
}

// The shot timer requires the caller to do a bit of maths to get the actual
// shot time in milliseconds:
//
// if (StateUpdate.mode == MachineMode.BREWING) {
//   return (StateUpdate.millis - ShotTimer.start)
// } else {
//   return (ShotTimer.stop - ShotTimer.start)
// }
//
// Start/Stop could also be used together with StateUpdate.millis to establish
// _when_ the last shot was pulled.
message ShotTimer {
  uint32 start = 1;
  uint32 stop = 2;
}

message StateUpdate {
  MachineMode mode = 1;
  Int32Result boilerTemp = 2;
  Uint32Result pressure = 3;
  int32 setpoint = 4;

  // Current time of machine since startup in milliseconds
  // as returned by the Arduino function millis().
  //
  // This is intended to be used for a client to synchronise time with
  // the server so it can make sense of things like shot timers
  // which aren't expressed as a straight up count but as timestamps.
  //
  // This number can also be used to display the uptime of the machine.
  uint32 millis = 5;

  ShotTimer shot_timer = 6;
}

message LogMessage {
  enum LogLevel{
    ERROR = 0;
    INFO = 1;
    DEBUG = 2;
  }
  LogLevel logLevel = 1;
  string msg = 2;
}

message Event {
  // If this event was in response to a request id it will contain one, otherwise empty
  bytes request_id = 1;

  oneof event_oneof {
    // Contains the current state of the machine
    StateUpdate state_update = 2;

    // Get updated configuration
    Config config = 3;

    // Generic log message
    LogMessage log = 4;
  }
}
